<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Module Collapsing Graph</title>
  <script src="https://unpkg.com/cytoscape@3.25.0/dist/cytoscape.min.js"></script>
  <style>
    html, body, #cy {
      width: 100%;
      height: 100%;
      margin: 0;
      background: #111;
    }
    #side-panel {
      position: fixed;
      top: 0;
      right: 0;
      width: 320px;
      height: 100%;
      background: #1e1e1e;
      color: #fff;
      padding: 1rem;
      box-shadow: -2px 0 8px rgba(0, 0, 0, 0.4);
      overflow-y: auto;
      font-family: sans-serif;
      display: none;
      z-index: 10000;
    }
  
    #side-panel h2 {
      margin-top: 0;
      font-size: 1.25rem;
      word-break: break-all;
    }
  
    #side-panel a {
      color: #81d4fa;
      text-decoration: underline;
    }
  
    #side-panel .label {
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div style="padding: 10px; background: #222; color: white; font-family: sans-serif;">
    <label for="filter-type">Filter:</label>
    <select id="filter-type">
      <option value="node">Node</option>
      <option value="edge">Edge</option>
    </select>

    <label for="filter-type">Minimum Score:</label>
    <input id="filter-min-score" placeholder="100" value="100", style="width: 100px;" />

    <label for="filter-type">Path:</label>
    <input id="filter-path" placeholder="sage.rings" style="width: 100px;" />
  
    <button onclick="applyFilter()">Apply Filter</button>
    <button onclick="resetFilter()">Reset</button>
  </div>

  <div id="side-panel">
    <button onclick="closePanel()">X</button>
    <p></p>
    <h2 id="panel-title"></h2>
    <p><span class="label">Type:</span> <span id="panel-type"></span></p>
    <p><span class="label">Score:</span> <span id="panel-score"></span></p>
    <p><span class="label">Docs:</span> <a id="panel-doc" href="#" target="_blank">Open</a></p>
  </div>

  <div id="cy"></div>

  <script>
    const settings = {
      minScore: 100,
      path: "sage.rings",
      edgeTypes: new Set([0,1,2,3])
    }

    const cy = cytoscape({
      container: document.getElementById('cy'),
      //elements: data.elements,
      style: [
        {
          selector: 'node',
          style: {
            'label': 'data(id)',
            'background-color': '#29b6f6',
            'text-valign': 'center',
            'text-halign': 'center',
            'color': '#fff',
            'font-size': '10px'
          }
        },
        {
          selector: ':parent',
          style: {
            'background-color': '#455a64',
            'text-valign': 'top',
            'padding': 10,
            'font-size': '12px'
          }
        },
        {
          selector: 'edge',
          style: {
            'width': 2,
            'line-color': '#ccc',
            'target-arrow-shape': 'triangle',
            'target-arrow-color': '#ccc',
            'curve-style': 'bezier',
            //'label': 'data(label)',
            'font-size': '8px',
            'color': '#aaa'
          }
        }
      ],
    });

    const collapsedModules = new Set();

    function isAncestor(ancestorId, nodeId) {
      let current = cy.getElementById(nodeId);
      while (current.data('parent')) {
        if (current.data('parent') === ancestorId) return true;
        current = cy.getElementById(current.data('parent'));
      }
      return false;
    }

    function getAllAncestors(nodeId) {
      const ancestors = new Set();
      let node = cy.getElementById(nodeId);
      ancestors.add(node);
      while (node.data('parent')) {
        node = cy.getElementById(node.data('parent'));
        ancestors.add(node);
      }
      return ancestors
    }

    function createSuperEdges() {
      cy.edges().forEach(
        edge => {
          const sourceAncestors = getAllAncestors(edge.data('source'));
          const targetAncestors = getAllAncestors(edge.data('target'));

          sourceAncestors.forEach(
            source => {
              targetAncestors.forEach(
                target => {
                  if (
                    source.id() != target.id() && 
                    !isAncestor(source.id(), target.id()) && 
                    !isAncestor(target.id(), source.id())
                  ) {
                    const superId = `${source.id()}-${target.id()}`;
                    let superEdge = cy.getElementById(superId);
                    if (superEdge.length === 0) {
                      superEdge = cy.add({
                        group: 'edges',
                        data: {
                          id: superId,
                          source: source.id(),
                          target: target.id(),
                          isSuper: true,
                          type: edge.data('type'),
                        }
                      });
                    } else if (edge.data('type') > superEdge.data('type')) {
                      superEdge.data('type', edge.data('type'))
                    }
                  }
                }
              )
            }
          )
        }
      )
    }

    function showVisibleEdges() {
      cy.edges().forEach( edge => {
        const sourceNode = cy.getElementById(edge.data('source'));
        const targetNode = cy.getElementById(edge.data('target'));
        const sourceNotExpanded = collapsedModules.has(sourceNode.id()) || !sourceNode.isParent()
        const targetNotExpanded = collapsedModules.has(targetNode.id()) || !targetNode.isParent()
        if (sourceNode.visible() && targetNode.visible() && sourceNotExpanded && targetNotExpanded) {
          edge.show()
        } else {
          edge.hide()
        }
      });
    }

    /***
     * Recursively collapses a module and all descendents.
     * Typically called as a subroutine of collapseModule and collapseAllmodules
     */
    function collapseRecursive(subModuleId) {
      //if (collapsedModules.has(subModuleId)) return;
      collapsedModules.add(subModuleId);
      //console.log(`Collapsing ${moduleId}`)
      const childNodes = cy.nodes(`[parent = "${subModuleId}"]`);

      // Collapse nested modules first
      childNodes.forEach(child => {
        if (child.isParent()) {
          collapseRecursive(child.id());
        }
      });

      // Hide children and edges
      childNodes.forEach(n => n.hide());
    }

    /***
     * Collapses a module and updates edge visibility
     */
    function collapseModule(moduleId) {
      collapseRecursive(moduleId);
      showVisibleEdges();
    }

    /***
     * Expands a module and, if applicable, all ancestor modules
     */
    function expandModule(moduleId) {
      // Recursively expand parent modules
      const module = cy.getElementById(moduleId);
      if (module.data('parent')) {
        expandModule(module.data('parent'));
      }

      const childNodes = cy.nodes(`[parent = "${moduleId}"]`);
      collapsedModules.delete(moduleId);

      // Show original nodes and edges
      childNodes.forEach(n => n.show());
      showVisibleEdges();
    }

    /***
     * Collapses all modules but does not update edge visibility status 
     * (this needs to be done manually)
     */
    function collapseAllModules() {
      const allModules = cy.nodes().filter(n => n.isParent());
      allModules.forEach(module => collapseRecursive(module.id()));
    }

    /***
     * Takes a json of node and edge data and returns a filtered set of data
     */
    function getFilteredElements(data, settings) {
      const nodes = data.elements.nodes.filter(
        node =>
        node.data.score > settings.minScore &&
        node.data.id.startsWith(settings.path)
      );
      const nodeIds = nodes.map(node => node.data.id);
      
      const edges = data.elements.edges.filter(
        edge =>
        nodeIds.includes(edge.data.source) && nodeIds.includes(edge.data.target)
      ).map(edge => {
        const updatedEdge = edge;
        updatedEdge.data.isSuper = false;
        return updatedEdge;
      });

      return {
        nodes: nodes,
        edges: edges
      };
    }

    /*
      Obtains filter settings input by the user and updates the "filter" object
      Loads and removes relevant nodes and edges
      Collapses all modules
    */
    function applyFilter() {
      settings.minScore = parseFloat(document.getElementById("filter-min-score").value, 100);
      settings.path = document.getElementById("filter-path").value
      return fetch("graph.json")
      .then(res => res.json())
      .then(data => {
        const filteredData = getFilteredElements(data, settings);
        const newNodes = filteredData.nodes.filter(node => {
          const id = node.data?.id;
          return id && cy.getElementById(id).empty();
        });
        const newEdges = filteredData.edges.filter(edge => {
          const id = edge.data?.id;
          return id && cy.getElementById(id).empty();
        });

        cy.batch(() => {
          cy.add(
            {
              nodes: newNodes,
              edges: newEdges
            }
          );
          cy.edges().forEach(
            edge => {
              if (edge.data('isSuper')) {
                edge.remove();
              }
            }
          )

          // Handle filtered out nodes
          cy.nodes().forEach(
            node => {
              if (node.data('score') < settings.minScore) {
                // Remove filtered out nodes
                node.remove();
              }
            }
          )
        });

        requestAnimationFrame(() => {
          const newNodes = cy.nodes().filter(n => n.visible());
          const nodeSet = cy.collection(newNodes);
          const edgeSet = nodeSet.connectedEdges();
          const toLayout = nodeSet.union(edgeSet);
          const layout = toLayout.layout({
            name: 'breadthfirst',
            directed: true,
            padding: 10
          });

          cy.once('layoutstop', () => {
            createSuperEdges();
            collapseAllModules();
            showVisibleEdges();
          });

          layout.run();
        });
      })
    }

    /* 
    Sets filter back to default settings
    TODO - does not currently work
    */
    function resetFilter() {
      settings.minScore = 100;
      settings.path = "sage.rings"
      applyFilter().then(() => {
        collapseAllModules();
      });
    }

    /*
    Displays side panel with metadata information about the selected node
    */
    function showSidePanel(label, type, score, fqname, urls ) {
      const panel = document.getElementById("side-panel");
      document.getElementById("panel-title").textContent = label || fqname;
      document.getElementById("panel-type").textContent = type || "unknown";
      document.getElementById("panel-score").textContent = score ?? "n/a";

      const docLink = document.getElementById("panel-doc");
      docLink.textContent = "Loading";
      if (urls)  {
        docLink.textContent = urls[0];
        docLink.href = urls[0];
      }
      else {
        docLink.textContent = "Could not find documentation.";
        docLink.removeAttribute("href");
      }

      panel.style.display = "block";
    }

    /*
    Hides the side panel.
    */
    function closePanel() {
      const panel = document.getElementById("side-panel");
      panel.style.display = "none";
    }


    /*
    Toggle modules on click
    */
    cy.on('tap', 'node', function(evt) {
      const node = evt.target;
      if (!node.isParent()) {
        console.log(node);
        console.log(node.data());
        showSidePanel(node.data('label'), node.data('type'), node.data('score'), node.id(), node.data('urls'));
        return;
      }

      const moduleId = node.id();
      if (collapsedModules.has(moduleId)) {
        expandModule(moduleId);
      } else {
        collapseModule(moduleId);
      }
    });

    /*
    Initial fetch based on default filter settings. 
    Loads and renders the nodes and edges in collapsed form.
    */
    fetch("graph.json")
      .then(res => res.json())
      .then(data => {
        console.log("Data loaded")
        const filteredData = getFilteredElements(data, settings);
        
        cy.add(filteredData);

        const layout = cy.layout({
          name: 'breadthfirst',
          directed: true,
          padding: 10
        });

        cy.once('layoutstop', () => {
          createSuperEdges();
          collapseAllModules();
          showVisibleEdges();
          console.log("Modules collapsed.");
        });

        layout.run();

        console.log("cy initialized")
      })
  </script>
</body>
</html>