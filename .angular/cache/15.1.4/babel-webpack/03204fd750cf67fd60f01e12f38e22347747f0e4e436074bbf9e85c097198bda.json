{"ast":null,"code":"import * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common\";\nimport * as i2 from \"@angular/material/button\";\nimport * as i3 from \"@angular/forms\";\nfunction TwentyFourComponent_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\")(1, \"div\", 13);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const card_r3 = ctx.$implicit;\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", card_r3, \" \");\n  }\n}\nfunction TwentyFourComponent_div_23_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 2);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ans_r4 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ans_r4, \" \");\n  }\n}\nconst epsilon = 0.01;\nexport let TwentyFourComponent = /*#__PURE__*/(() => {\n  class TwentyFourComponent {\n    onResize(event) {}\n    constructor() {\n      this.cards = [3, 4, 5, 6];\n      this.inputText = '';\n      this.message = '';\n      this.answers = [];\n    }\n    ngOnInit() {\n      this.onNewGame();\n    }\n    onSubmit(answer) {\n      let tree = null;\n      try {\n        tree = this.parsePM(answer);\n        if (!this.isValid(tree)) {\n          this.message = \"You must use each number exactly once.\";\n        } else if (this.isCorrect(tree)) {\n          this.message = \"Correct!\";\n        } else {\n          this.message = \"This evaluates to \" + Math.round(this.evaluate(tree).toString() * 100) / 100 + \".\";\n        }\n      } catch (error) {\n        this.message = error;\n      }\n    }\n    onNewGame() {\n      this.message = '';\n      this.answers = [];\n      this.cards = [];\n      for (let i = 0; i < 4; ++i) {\n        this.cards.push(1 + Math.floor(Math.random() * 10));\n      }\n      if (solve(this.cards).size == 0) {\n        this.onNewGame();\n      } else {\n        this.cards.sort();\n      }\n    }\n    recur(expr) {\n      if (expr == '') {\n        throw new Error(\"Invalid Expression.\");\n      }\n      let parantheses = 0;\n      for (let i = expr.length - 1; i >= 0; --i) {\n        if (expr[i] == \"(\") {\n          ++parantheses;\n        } else if (expr[i] == \")\") {\n          --parantheses;\n        } else if (['+', '-'].indexOf(expr[i]) != -1 && parantheses == 0) {\n          return [expr[i], this.recur(expr.substring(0, i)), this.recur(expr.substring(i + 1, expr.length))];\n        }\n      }\n      for (let i = expr.length - 1; i >= 0; --i) {\n        if (expr[i] == \"(\") {\n          ++parantheses;\n        } else if (expr[i] == \")\") {\n          --parantheses;\n        } else if (['*', '\\/'].indexOf(expr[i]) != -1 && parantheses == 0) {\n          return [expr[i], this.recur(expr.substring(0, i)), this.recur(expr.substring(i + 1, expr.length))];\n        }\n      }\n      if (!isNaN(expr)) {\n        return Number(expr);\n      }\n      if (expr[0] == \"(\" && expr[expr.length - 1] == \")\") {\n        return this.recur(expr.substring(1, expr.length - 1));\n      }\n      throw new Error(\"Invalid Expression.\");\n    }\n    parsePM(expr) {\n      return this.recur(expr.replaceAll(' ', ''));\n    }\n    isValid(exprTree) {\n      let numList = [];\n      let stack = [exprTree];\n      while (stack.length > 0) {\n        let cur = stack.pop();\n        if (!isNaN(cur)) {\n          numList.push(cur);\n        } else {\n          stack.push(cur[1]);\n          stack.push(cur[2]);\n        }\n      }\n      numList.sort();\n      if (numList.length != 4) {\n        return false;\n      }\n      for (let i = 0; i < 4; ++i) {\n        if (numList[i] != this.cards[i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n    isCorrect(tree) {\n      return Math.abs(this.evaluate(tree) - 24) < epsilon;\n    }\n    evaluate(tree) {\n      if (!isNaN(tree)) {\n        return tree;\n      } else if (tree[0] == '+') {\n        return this.evaluate(tree[1]) + this.evaluate(tree[2]);\n      } else if (tree[0] == '*') {\n        return this.evaluate(tree[1]) * this.evaluate(tree[2]);\n      } else if (tree[0] == '-') {\n        return this.evaluate(tree[1]) - this.evaluate(tree[2]);\n      } else if (tree[0] == '\\/') {\n        return this.evaluate(tree[1]) / this.evaluate(tree[2]);\n      }\n    }\n    onShowAnswers() {\n      this.answers = [...solve(this.cards)];\n    }\n  }\n  TwentyFourComponent.ɵfac = function TwentyFourComponent_Factory(t) {\n    return new (t || TwentyFourComponent)();\n  };\n  TwentyFourComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: TwentyFourComponent,\n    selectors: [[\"pm-twentyfour\"]],\n    hostBindings: function TwentyFourComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"resize\", function TwentyFourComponent_resize_HostBindingHandler($event) {\n          return ctx.onResize($event);\n        }, false, i0.ɵɵresolveWindow);\n      }\n    },\n    decls: 25,\n    vars: 3,\n    consts: [[1, \"large-break\"], [1, \"flex-container\", \"vertical\"], [1, \"center\"], [1, \"cards-container\", \"center\"], [4, \"ngFor\", \"ngForOf\"], [1, \"medium-break\"], [3, \"ngSubmit\"], [\"answer\", \"ngForm\"], [\"type\", \"text\", \"name\", \"value\", \"placeholder\", \"answer\", \"ngModel\", \"\", 1, \"equationbox\"], [\"mat-raised-button\", \"\", \"type\", \"submit\", 1, \"checkbutton\"], [1, \"small-break\"], [\"mat-raised-button\", \"\", \"type\", \"button\", 1, \"checkbutton\", 3, \"click\"], [\"class\", \"center\", 4, \"ngFor\", \"ngForOf\"], [1, \"card\", \"center\"]],\n    template: function TwentyFourComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        const _r5 = i0.ɵɵgetCurrentView();\n        i0.ɵɵelement(0, \"div\", 0);\n        i0.ɵɵelementStart(1, \"div\", 1)(2, \"div\", 2)(3, \"div\", 3);\n        i0.ɵɵtemplate(4, TwentyFourComponent_div_4_Template, 3, 1, \"div\", 4);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelement(5, \"div\", 5);\n        i0.ɵɵelementStart(6, \"div\", 1)(7, \"div\", 2)(8, \"form\", 6, 7);\n        i0.ɵɵlistener(\"ngSubmit\", function TwentyFourComponent_Template_form_ngSubmit_8_listener() {\n          i0.ɵɵrestoreView(_r5);\n          const _r1 = i0.ɵɵreference(9);\n          return i0.ɵɵresetView(ctx.onSubmit(_r1.value.value));\n        });\n        i0.ɵɵelement(10, \"input\", 8);\n        i0.ɵɵelementStart(11, \"button\", 9);\n        i0.ɵɵtext(12, \"Check\");\n        i0.ɵɵelementEnd()()();\n        i0.ɵɵelement(13, \"div\", 10);\n        i0.ɵɵelementStart(14, \"div\", 2)(15, \"button\", 11);\n        i0.ɵɵlistener(\"click\", function TwentyFourComponent_Template_button_click_15_listener() {\n          return ctx.onShowAnswers();\n        });\n        i0.ɵɵtext(16, \"Show Answers\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(17, \"button\", 11);\n        i0.ɵɵlistener(\"click\", function TwentyFourComponent_Template_button_click_17_listener() {\n          return ctx.onNewGame();\n        });\n        i0.ɵɵtext(18, \"New Game\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelement(19, \"div\", 10);\n        i0.ɵɵelementStart(20, \"div\", 2);\n        i0.ɵɵtext(21);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(22, \"div\", 1);\n        i0.ɵɵtemplate(23, TwentyFourComponent_div_23_Template, 2, 1, \"div\", 12);\n        i0.ɵɵelementEnd()()();\n        i0.ɵɵelement(24, \"div\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(4);\n        i0.ɵɵproperty(\"ngForOf\", ctx.cards);\n        i0.ɵɵadvance(17);\n        i0.ɵɵtextInterpolate1(\" \", ctx.message, \" \");\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngForOf\", ctx.answers);\n      }\n    },\n    dependencies: [i1.NgForOf, i2.MatButton, i3.ɵNgNoValidate, i3.DefaultValueAccessor, i3.NgControlStatus, i3.NgControlStatusGroup, i3.NgModel, i3.NgForm],\n    styles: [\".large-break[_ngcontent-%COMP%]{height:120px}.medium-break[_ngcontent-%COMP%]{height:50px}.small-break[_ngcontent-%COMP%]{height:20px}.p-h-5[_ngcontent-%COMP%]{padding-left:5%;padding-right:5%}.p-h-10[_ngcontent-%COMP%]{padding-left:10%;padding-right:10%}.center[_ngcontent-%COMP%]{display:flex;justify-content:center}.title-text[_ngcontent-%COMP%]{font-size:300%;font-family:\\\"math\\\";color:#000;height:-moz-fit-content;height:fit-content;line-height:100%}.light[_ngcontent-%COMP%]{background-color:#6697d8;border-color:#6697d8}.dark[_ngcontent-%COMP%]{background-color:#4663ac;border-color:#4663ac}.flex-container[_ngcontent-%COMP%]{display:flex;justify-content:flex-start;border-width:large}.flex-container.horizontal[_ngcontent-%COMP%]{flex-direction:row}.flex-container.vertical[_ngcontent-%COMP%]{flex-direction:column}.paragraph-text[_ngcontent-%COMP%]{font-size:24px;font-family:\\\"math\\\";color:#fff;height:-moz-fit-content;height:fit-content;line-height:32px;text-align:justify;text-justify:inter-word}@media (max-width:720px){.paragraph-text[_ngcontent-%COMP%]{font-size:16px;line-height:24px}.title-text[_ngcontent-%COMP%]{font-size:32px;line-height:32px}}.ignore-others[_ngcontent-%COMP%]{z-index:999;position:fixed}.cards-container[_ngcontent-%COMP%]{display:inline-grid;grid-column-gap:20px;grid-template-columns:repeat(2,1fr);justify-content:center!important;align-items:center!important;padding-top:30px;padding-bottom:30px;grid-row-gap:100px;width:60%}@media (max-width:720px){.cards-container[_ngcontent-%COMP%]{width:100%}}.card[_ngcontent-%COMP%]{background-color:transparent;border:none;text-align:center;padding:none;font-size:100px}.equationbox[_ngcontent-%COMP%]{margin-right:20px}.checkbutton[_ngcontent-%COMP%]{margin-right:10px;max-width:150px}\"]\n  });\n  return TwentyFourComponent;\n})();\nlet Type = /*#__PURE__*/(() => {\n  class Type {}\n  Type.Operation = 1;\n  Type.Number = 2;\n  return Type;\n})();\nlet Operation = /*#__PURE__*/(() => {\n  class Operation {}\n  Operation.ADD = '+';\n  Operation.SUB = '-';\n  Operation.MUL = '*';\n  Operation.DIV = '/';\n  return Operation;\n})();\nclass MyNode {\n  constructor(type) {\n    this.type = type;\n    this.negatives = false;\n  }\n  setNum(number) {\n    this.number = number;\n  }\n  set_op(operation) {\n    this.operation = operation;\n  }\n  set_children(left, right) {\n    this.left = left;\n    this.right = right;\n  }\n  get_num() {\n    return this.number;\n  }\n  get_op() {\n    return this.operation;\n  }\n  has_negatives() {\n    if (this.type == Type.Number) {\n      return this.get_num() < 0;\n    }\n    return this.eval() < 0 || this.left.has_negatives() || this.right.has_negatives() < 0;\n  }\n  flatten() {\n    if (this.type == Type.Number) {\n      this.exprs = [this];\n      return;\n    }\n    this.left.flatten();\n    this.right.flatten();\n    if (this.operation == Operation.ADD || this.operation == Operation.MUL) {\n      if (this.left.type == Type.Number) {\n        this.exprs = this.left.exprs;\n      } else if (this.left.operation == this.operation) {\n        this.exprs = this.left.exprs;\n      } else {\n        this.exprs = [this.left];\n      }\n      if (this.right.type == Type.Number) {\n        this.exprs = this.exprs.concat(this.right.exprs);\n      } else if (this.right.operation == this.operation) {\n        this.exprs = this.exprs.concat(this.right.exprs);\n      } else {\n        this.exprs = this.exprs.concat([this.right]);\n      }\n      return this.exprs;\n    } else {\n      if (this.left.type == Type.Number) {\n        this.exprs = [this.left, this.right];\n      } else if (this.left.operation == this.operation) {\n        this.exprs = this.left.exprs.concat([this.right]);\n      } else {\n        this.exprs = [this.left, this.right];\n      }\n      return this.exprs;\n    }\n  }\n  arrange() {\n    if (this.type == Type.Operation) {\n      if (this.operation == Operation.ADD || this.operation == Operation.MUL) {\n        this.exprs.sort((x, y) => x.eval() > y.eval() ? 1 : -1);\n      } else {\n        let sub = this.exprs.slice(1);\n        this.exprs = [this.exprs[0]].concat(sub.sort((x, y) => x.eval() > y.eval() ? 1 : -1));\n      }\n      this.exprs.forEach(expr => {\n        expr.arrange();\n      });\n    }\n  }\n  eval() {\n    if (this.type == Type.Number) return this.get_num();else if (this.operation == Operation.ADD) return this.exprs.reduce((x, y) => x + y.eval(), 0);else if (this.operation == Operation.SUB) return this.exprs[0].eval() - this.exprs.slice(1).reduce((x, y) => x + y.eval(), 0);else if (this.operation == Operation.MUL) return this.exprs.reduce((x, y) => x * y.eval(), 1);else if (this.operation == Operation.DIV) return this.exprs[0].eval() / this.exprs.slice(1).reduce((x, y) => x * y.eval(), 1);\n  }\n  toString() {\n    if (true) {\n      if (this.type == Type.Number) return this.get_num().toString();else return '(' + this.exprs.reduce((x, y) => x + \" \" + this.operation + \" \" + y.toString()) + ')';\n    } else if (this.type == Type.Number) return this.get_num().toString();else return '(' + this.left.toString() + ' ' + this.operation + ' ' + this.right.toString() + ')';\n  }\n}\nlet structures = [[Type.Operation, [Type.Operation, [Type.Operation, Type.Number, Type.Number], Type.Number], Type.Number], [Type.Operation, [Type.Operation, Type.Number, [Type.Operation, Type.Number, Type.Number]], Type.Number], [Type.Operation, [Type.Operation, Type.Number, Type.Number], [Type.Operation, Type.Number, Type.Number]], [Type.Operation, Type.Number, [Type.Operation, [Type.Operation, Type.Number, Type.Number], Type.Number]], [Type.Operation, Type.Number, [Type.Operation, Type.Number, [Type.Operation, Type.Number, Type.Number]]]];\nfunction generate_tree(structure, op_list, num_list) {\n  if (structure == Type.Number) {\n    let node = new MyNode(Type.Number);\n    node.setNum(num_list.pop());\n    return node;\n  } else if (structure[0] == Type.Operation) {\n    let node = new MyNode(Type.Operation);\n    node.set_op(op_list.pop());\n    let left = generate_tree(structure[1], op_list, num_list);\n    let right = generate_tree(structure[2], op_list, num_list);\n    node.set_children(left, right);\n    return node;\n  }\n}\n// Helper function copied from https://stackoverflow.com/questions/37579994/generate-permutations-of-javascript-array\nfunction permutations(xs) {\n  let ret = [];\n  for (let i = 0; i < xs.length; i = i + 1) {\n    let rest = permutations(xs.slice(0, i).concat(xs.slice(i + 1)));\n    if (!rest.length) {\n      ret.push([xs[i]]);\n    } else {\n      for (let j = 0; j < rest.length; j = j + 1) {\n        ret.push([xs[i]].concat(rest[j]));\n      }\n    }\n  }\n  return ret;\n}\nlet ops = [Operation.ADD, Operation.SUB, Operation.MUL, Operation.DIV];\nlet num_list = [1, 2, 3, 4];\nfunction solve(nums) {\n  let solutions = [];\n  structures.forEach(structure => {\n    permutations(nums).forEach(perm => {\n      ops.forEach(x => {\n        ops.forEach(y => {\n          ops.forEach(z => {\n            let cur = generate_tree(structure, [x, y, z], perm.slice(0));\n            cur.flatten();\n            cur.arrange();\n            if (cur.eval() - 24 < epsilon && 24 - cur.eval() < epsilon) {\n              solutions.push(cur.toString());\n            }\n          });\n        });\n      });\n    });\n  });\n  return new Set(solutions);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}